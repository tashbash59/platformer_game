# Ответы на тестовое

## 1) Как работает система сцены в Godot и в чем ее преимущества? 

Сцены в Godot основаны на иерархической структуре узлов, каждая сцена - это независимый, переиспользуемый компонент.

Преимущества:
- Каждая сцена инкапсулирует логику
- Сцены можно инстанциировать множество раз
- Изменения в одной сцене не ломают другие

## 2) Объясните, как работают сигналы (Signals) в Godot? Приведите общий пример использования сигналов и\или двух несвязанных между собой node (Не имеющие общего родителя)

Сигналы в Godot позволяют объектам взаимодействовать друг с другом без прямых ссылок.

### Пример: Сбор монетки игроком

Скрипт монетки:
```gdscript
# Объявляем сигнал - монетка может сообщить о своем сборе
signal collected

func _on_body_entered(body):
    if body.name == "Player":
        # Испускаем сигнал когда игрок касается монетки
        collected.emit()
        queue_free()
```

Скрипт игрока:
```gdscript
func _ready():
    # Подписываемся на сигнал от монетки
    var coin = get_node("../Coin")
    coin.collected.connect(_on_coin_collected)

func _on_coin_collected():
    print("Монетка собрана!")
    # Увеличиваем счет и т.д.
```

## 3) Как в GDScript организовать наследование, и зачем это нужно?

Наследование позволяет создавать классы на основе существующих, что позволяет расширять функционал, не повторяясь.

### Пример наследования:

Базовый класс:
```gdscript
class_name Character

# Общие свойства для всех персонажей
var health: int = 100
var move_speed: float = 200.0

func take_damage(damage: int):
    health -= damage
    if health <= 0:
        die()

# метод для переопределения
func _update_animation():
    pass
```
Дочерний класс:
```gdscript
class_name Player

# Специфичные для игрока свойства
var jump_force: float = -400.0
var coins: int = 0

# Переопределяем метод
func _update_animation():
    if velocity.x != 0:
        $AnimatedSprite2D.play("run")
    else:
        $AnimatedSprite2D.play("idle")

# Добавляем новый метод
func collect_coin():
    coins += 1
    print("Coins: ", coins)
```

## 4) Как работает система импорта ресурсов в Godot?

Система импорта Godot автоматически конвертирует исходные файлы в оптимизированные игровые ресурсы.

- При изменении исходного файла Godot обнаруживает это и переимпортирует ресурс
- Применяет настройки из соответствующего .import файла

## 5) Что такое _process() и _physics_process() в GDScript и чем они отличаются?

_process() и _physics_process() - функции которые вызываются каждый промежуток времени:

- _process() - частота зависит от системы
- _physics_process() - частота фиксирована (по умолчанию 60 FPS)

## 6) Как создать и использовать таймер (Timer) в Godot?

Таймер можно создать несколькими способами:

### Через узел:
- Добавить узел Timer в сцену
- Подключить сигнал timeout в необходимый скрипт

### Из кода:
```gdscript
# Способ 1
timer = Timer.new()
add_child(timer)

# Способ 2
await get_tree().create_timer(1.0).timeout
```

## 7) Объясните, как работает система слоев и масок (Layers and Masks) для коллизий в Godot.
Слои определяют принадлежность объекта к группе коллизий.
Маски определяют с какими слоями объект будет сталкиваться.
### Пример:
- Герой взаимодействует с монетками
- Враг игнорирует монетки, но взаимодействует с героем

Настройка:
- Маска героя включает слой монетки
- Маска врага включает только слой героя

## 8) Как в GDScript организовать взаимодействие между разными сценами или узлами?

- Сигналы - объекты объявляют сигналы для событий, а другие объекты подписываются на них

- Группы - можно получить все узлы определенной группы и взаимодействовать с ними.

- Прямой поиск узлов по пути или имени через методы вроде get_node() или find_child()

## 9) Как загрузить и инстанцировать сцену динамически во время выполнения игры?

```gdscript
#загрузка сцены врага из файла
var enemy_scene: PackedScene = load("res://scenes/enemy.tscn")
    
#создание экземпляра сцены
var enemy_instance: Node2D = enemy_scene.instantiate()
    
#настройка экземпляра
enemy_instance.position = Vector2(500, 300)
enemy_instance.speed = 150.0
    
#добавление на сцену
add_child(enemy_instance)
```

## 10) Какие средства профилирования и отладки предоставляет Godot?

- Дебаггер: Точки останова, пошаговое выполнение, просмотр переменных в реальном времени.
- Профилировщик: Анализ производительности - время кадра, физика, скрипты, использование памяти.
- Визуальная отладка: Отображение коллайдеров, навигационных сеток и путей.
- Консоль: Вывод отладочной информации через print(), assert для проверок.

## 11) Как реализовать систему сохранения и загрузки данных игры в Godot? Какие существуют подходы и какие классы для этого используются?
для реализации неоходимо собрать данные игры в словарь, сохранить через ConfigFile или FileAccess, далее данные прочитать и восстановить.
класы которые для этого ипользуются:
- ConfigFile - работа с .cfg файлами
- FileAccess - низкоуровневые файловые операции
- JSON - парсинг и создание JSON
- ResourceSaver/Loader - сохранение ресурсов

## 12) Как подключить и использовать Android плагины в Godot? Какие шаги необходимы для интеграции?

Поместить файлы плагина в проект, включить плагин в настройках экспорта, использовать в виде
```gdscript
if Engine.has_singleton("имя плагина"):
    var plugin = Engine.get_singleton("имя плагина")
    plugin.call_method("имя метода")
```


